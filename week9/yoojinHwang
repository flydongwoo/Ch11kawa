// 성공
// 백준 영화감독 숌
// 666은 종말을 나타내는 수
// 제일 작은 종말의 수 = 666, 다음으로 1666, 2666, 3666, ...


#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ctype.h>

int endNum(int n);

int main(void) {
	int N = 0;

	scanf("%d", &N);

	int result = endNum(N);
	printf("%d", result);
	return 0;
}

int endNum(int n) {
	int num = 0;   // 카운트 숫자
	int count = 0; // 몇 번째 종말의 수인지
	int isSix = 0; // 6인지

	while (1) {
		if (count == n)
			return num;
		num++;
		char test[20];
		sprintf(test, "%d", num);

		if (strstr(test, "666") != NULL)
			count++;

	}
}

// --------------------------------------------------------------------

// 실패
// 뭐가 잘못된 건지 도저히 모르겠습니다..?

// 백준 22938
// 백발백준하는 명사수

// 두 과녁이 겹치는 부분이 있어 한번에 맞추기가 가능한지 검사
// 원 모양으로 생긴 두 과녁이 겹치는 부분이 존재하는지 확인

// 첫 번째 과녁의 중심 X1, Y1, 반지름 R1
// 두 번째 과녁의 중심 X2, Y2, 반지름 R2

// 과녁이 겹치면 YES, 아니면 NO
// 두 과녁이 한 점에서 만나는 경우는 겹치지 않는 것으로 간주

#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <math.h>

void robinhood(int X, int R1, int R2);

int main(void) {
	int X1, Y1, R1;
	int X2, Y2, R2;

	scanf("%d %d %d", &X1, &Y1, &R1);
	scanf("%d %d %d", &X2, &Y2, &R2);

	int X = pow((X1 - X2), 2) + pow((Y1 - Y2), 2);

	robinhood(X, R1, R2);

	return 0;
}
void robinhood(int X, int R1, int R2) {
	if (X <= pow((R1 - R2), 2) || X >= pow((R1 + R2), 2))
		printf("NO");
	else
		printf("YES");
}


//------------------------------------------------------------

// 이거 어떻게 푸는 거죠.....? 뭔가 A와 B 배열을 똑같은 크기로 정의하라고 하는데,,,, 
일단 뭔가 마땅한 방법을 찾지 못하고,, 
배열 크기를 제 마음대로 지정해서 동작하는 코드로 짜긴 했습니다......
// C언어 express 11

// 2개의 정렬된 정수 배열 A[], B[]
// 2개의 배열을 합쳐서 하나의 정렬된 배열 C[]로 만드는 함수 작성

// 배열 A[]와 B[]는 똑같은 크기로 정의되어 있음
// 배열 C[]에는 충분한 공간이 확보되어 있음

// A[0] B[0] 비교 -> A[0]이 작으면 C[0]에 복사
// A[1] B[0] 비교 ...
// A[]나 B[] 중 어느 하나가 먼저 끝나게 되면, 남아있는 요소들을 전부 C[]로 이동

#define _CRT_SECURE_NO_WARNINGS
#define SIZE 5
#include <stdio.h>

void merge(int* A, int* B, int* C, int size);

int main(void) {
	char X[100];
	int A[SIZE] = { 0 };
	int B[SIZE] = { 0 };
	int C[20] = { 0 };

	printf("A[] = ");
	gets(X);

	for (int i = 0; i < SIZE; i++) {
		scanf("%d ", &A[i]);
		if (A[i - 1] == 0) break;
	}
	printf("B[] = ");
	for (int i = 0; i < SIZE; i++) {
		scanf("%d ", &B[i]);
		if (B[i - 1] == 0) break;
	}
	merge(A, B, C, SIZE);

	return 0;
}
void merge(int* A, int* B, int* C, int size) {
	int i = 0, j = 0, k = 0;
	while (i <= size || j <= size) {
		if (A[i] <= B[j]) {
			C[k] = A[i];
			i++; k++;
		}
		else {
			C[k] = B[i];
			j++; k++;
		}
	}
	printf("C[] =");
	while (k >= 0) {
		printf(" %d", C[k]);
	}
	printf("\n");
}
