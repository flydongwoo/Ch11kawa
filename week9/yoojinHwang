// 성공
// 백준 영화감독 숌
// 666은 종말을 나타내는 수
// 제일 작은 종말의 수 = 666, 다음으로 1666, 2666, 3666, ...


#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ctype.h>

int endNum(int n);

int main(void) {
	int N = 0;

	scanf("%d", &N);

	int result = endNum(N);
	printf("%d", result);
	return 0;
}

int endNum(int n) {
	int num = 0;   // 카운트 숫자
	int count = 0; // 몇 번째 종말의 수인지
	int isSix = 0; // 6인지

	while (1) {
		if (count == n)
			return num;
		num++;
		char test[20];
		sprintf(test, "%d", num);

		if (strstr(test, "666") != NULL)
			count++;

	}
}

// --------------------------------------------------------------------

// 실패
// 뭐가 잘못된 건지 도저히 모르겠습니다..?

// 백준 22938
// 백발백준하는 명사수

// 두 과녁이 겹치는 부분이 있어 한번에 맞추기가 가능한지 검사
// 원 모양으로 생긴 두 과녁이 겹치는 부분이 존재하는지 확인

// 첫 번째 과녁의 중심 X1, Y1, 반지름 R1
// 두 번째 과녁의 중심 X2, Y2, 반지름 R2

// 과녁이 겹치면 YES, 아니면 NO
// 두 과녁이 한 점에서 만나는 경우는 겹치지 않는 것으로 간주

#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <math.h>

void robinhood(int X, int R1, int R2);

int main(void) {
	int X1, Y1, R1;
	int X2, Y2, R2;

	scanf("%d %d %d", &X1, &Y1, &R1);
	scanf("%d %d %d", &X2, &Y2, &R2);

	int X = pow((X1 - X2), 2) + pow((Y1 - Y2), 2);

	robinhood(X, R1, R2);

	return 0;
}
void robinhood(int X, int R1, int R2) {
	if (X <= pow((R1 - R2), 2) || X >= pow((R1 + R2), 2))
		printf("NO");
	else
		printf("YES");
}
